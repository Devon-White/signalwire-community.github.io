"use strict";(self.webpackChunksignalwire_community_docs=self.webpackChunksignalwire_community_docs||[]).push([[3775],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>d});var o=t(7294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,o,s=function(e,n){if(null==e)return{};var t,o,s={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var u=o.createContext({}),m=function(e){var n=o.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},c=function(e){var n=m(e.components);return o.createElement(u.Provider,{value:n},e.children)},l={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},p=o.forwardRef((function(e,n){var t=e.components,s=e.mdxType,r=e.originalType,u=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=m(t),d=s,k=p["".concat(u,".").concat(d)]||p[d]||l[d]||r;return t?o.createElement(k,a(a({ref:n},c),{},{components:t})):o.createElement(k,a({ref:n},c))}));function d(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var r=t.length,a=new Array(r);a[0]=p;var i={};for(var u in n)hasOwnProperty.call(n,u)&&(i[u]=n[u]);i.originalType=e,i.mdxType="string"==typeof e?e:s,a[1]=i;for(var m=2;m<r;m++)a[m]=t[m];return o.createElement.apply(null,a)}return o.createElement.apply(null,t)}p.displayName="MDXCreateElement"},6368:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>a,default:()=>l,frontMatter:()=>r,metadata:()=>i,toc:()=>m});var o=t(7462),s=(t(7294),t(3905));const r={sidebar_position:2},a="Hooks",i={unversionedId:"react/hooks",id:"react/hooks",title:"Hooks",description:"The hooks will automatically subscribe to and unsubscribe from Video events, maintain an up-to-date state, and trigger rerenders as necessary. This way your UI can keep track of the fluctuating state of things, like the ever-changing list of participants, current settings, etc, without a lot of code.",source:"@site/docs/react/hooks.mdx",sourceDirName:"react",slug:"/react/hooks",permalink:"/docs/react/hooks",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/react/hooks.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"reactSidebar",previous:{title:"VideoConference",permalink:"/docs/react/components/videoconference"}},u={},m=[{value:"Basic Hooks",id:"basic-hooks",level:2},{value:"useMembers",id:"usemembers",level:3},{value:"useStatus",id:"usestatus",level:3},{value:"useWebRTC",id:"usewebrtc",level:3},{value:"Additional Hooks",id:"additional-hooks",level:2},{value:"useLayouts",id:"uselayouts",level:3},{value:"usePermissions",id:"usepermissions",level:3},{value:"useScreenShare",id:"usescreenshare",level:3}],c={toc:m};function l(e){let{components:n,...t}=e;return(0,s.kt)("wrapper",(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"hooks"},"Hooks"),(0,s.kt)("p",null,"The hooks will automatically subscribe to and unsubscribe from Video events, maintain an up-to-date state, and trigger rerenders as necessary. This way your UI can keep track of the fluctuating state of things, like the ever-changing list of participants, current settings, etc, without a lot of code."),(0,s.kt)("p",null,"This will be the general form of your program using hooks. You can receive the RoomSession object either from the Video component, the Programmable Video Conferences (PVC) component, or, from your own code."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},'import { Video, useMembers } from "@signalwire-community/react";\nimport { useState } from "react";\n\nfunction App() {\n  const [roomSession, setRoomSession] = useState(null);\n  const { self } = useMembers(roomSession);\n  return (\n    <>\n      <Video\n        token={import.meta.env.VITE_ROOM_TOKEN}\n        onRoomReady={(e) => setRoomSession(e)}\n      />\n      I am {self?.name ?? "connecting.."}.\n    </>\n  );\n}\n')),(0,s.kt)("h2",{id:"basic-hooks"},"Basic Hooks"),(0,s.kt)("h3",{id:"usemembers"},"useMembers"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const { self, members, removeAll } = useMembers(roomSession);\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"useMembers")," maintains a list of all members in the rooms session, a reference to the current member, and a function to remove everyone. Some methods and properties are added to each member object so you can control their state and presence. Eg. ",(0,s.kt)("inlineCode",{parentName:"p"},'members.find(m=>m.name==="jane")?.audio.mute()')," or ",(0,s.kt)("inlineCode",{parentName:"p"},'!self.video.muted ? "Now you see me" : "Now you don\'t"')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},'import { useMembers } from "@signalwire-community/react";\nfunction App() {\n  const { self, members, removeAll } = useMembers(roomSession);\n  return (\n    <>\n      I am {self?.name ?? "connecting.."}.\n      {members.map((m) => (\n        <button onClick={() => m.remove()}>Remove {m.name}</button>\n      ))}\n      <button onClick={() => removeAll()}>Remove all</button>\n    </>\n  );\n}\n')),(0,s.kt)("h3",{id:"usestatus"},"useStatus"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const { active } = useStatus(roomSession);\n")),(0,s.kt)("p",null,"This hook takes a Room Session, and returns an object with its status information. The ",(0,s.kt)("inlineCode",{parentName:"p"},"active")," property is true as long as the client is connected to the Room Session."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},'import { useStatus } from "@signalwire-community/react";\n\nfunction App() {\n  const { active } = useStatus(roomSession);\n  return (\n      {active ? <Controls /> : <Loading />}\n  );\n}\n\n')),(0,s.kt)("h3",{id:"usewebrtc"},"useWebRTC"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const { microphones, cameras, speakers } = useWebRTC();\n")),(0,s.kt)("p",null,"Maintains an up-to-date list of permitted I/O devices, and tracks it's changes (eg. when user connects his headphones). This hook does not require a Room Session as an input. This hook keeps a list of cameras, microphones, and speakers by default. If you don't need to access camera at all, pass ",(0,s.kt)("inlineCode",{parentName:"p"},"{camera:false}"),". Same for microphone and speaker."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},'import { useWebRTC } from "@signalwire-community/react";\n\nfunction App() {\n  const { microphones, speakers } = useWebRTC({ camera: false });\n  return (\n    <>\n      {microphones.map((c) => (\n        <button onClick={() => roomSession?.updateMicrophone(c)}>\n          {c.label}\n        </button>\n      ))}\n    </>\n  );\n}\n')),(0,s.kt)("h2",{id:"additional-hooks"},"Additional Hooks"),(0,s.kt)("h3",{id:"uselayouts"},"useLayouts"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const { setLayout, layouts, currentLayout } = useLayouts(roomSession);\n")),(0,s.kt)("p",null,"Given an active RoomSession, ",(0,s.kt)("inlineCode",{parentName:"p"},"useLayouts")," maintains a list of all video layouts enabled in the room, the current layout, and a function to change between them."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},'import { useLayouts } from "@signalwire-community/react";\n\nfunction App() {\n  const { setLayout, layouts, currentLayout } = useLayouts(roomSession);\n  return (\n    <>\n      {currentLayout && (\n        <select\n          value={currentLayout}\n          onChange={(e) => {\n            setLayout({ name: e.target.value });\n          }}\n        >\n          {layouts.map((l) => (\n            <option>{l}</option>\n          ))}\n        </select>\n      )}\n    </>\n  );\n}\n')),(0,s.kt)("h3",{id:"usepermissions"},"usePermissions"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const P = usePermissions(roomSession);\n")),(0,s.kt)("p",null,"Parses the list of permissions given to the user in the room session, and returns an object that can be used to make UI decisions."),(0,s.kt)("p",null,"For example, if a permission is mentioned in the docs as ",(0,s.kt)("inlineCode",{parentName:"p"},'"room.member.audio_mute"'),", its status is available as the boolean ",(0,s.kt)("inlineCode",{parentName:"p"},"P?.member?.audio_mute"),". It is wise to use optional chaining in these cases, as ",(0,s.kt)("inlineCode",{parentName:"p"},"P")," is ",(0,s.kt)("strong",{parentName:"p"},(0,s.kt)("inlineCode",{parentName:"strong"},"null"))," before it receives the Room Session object, and ",(0,s.kt)("inlineCode",{parentName:"p"},"P.member")," can be ",(0,s.kt)("strong",{parentName:"p"},(0,s.kt)("inlineCode",{parentName:"strong"},"false"))," at times if the user doesn't have any member permissions at all."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},'import { Video, useMembers, usePermissions } from "@signalwire-community/react";\n\nfunction App() {\n  const P = usePermissions(roomSession);\n  const { self, members } = useMembers(roomSession);\n\n  return members.map((m) => (\n    <button\n      onClick={() => {\n        if (m === self) m.remove();\n        else {\n          if (P?.member?.remove) m.remove();\n          else alert("You aren\'t permitted to remove " + m.name);\n        }\n      }}\n    >\n      Remove {m.name}\n    </button>\n  ));\n}\n')),(0,s.kt)("h3",{id:"usescreenshare"},"useScreenShare"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const { toggle, active } = useScreenShare(roomSession);\n")),(0,s.kt)("p",null,"This hook takes a Room Session, and gives simple controls to start and stop screen sharing for a user."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},'import { usePermissions, useScreenShare } from "@signalwire-community/react";\n\nfunction App() {\n  const P = usePermissions(roomSession);\n  const { toggle, active } = useScreenShare(roomSession);\n  return (\n      {P?.self?.screenshare && (\n        <button onClick={() => toggle()}>{active ? "Stop" : "Start"}</button>\n      )}\n  );\n}\n\n')))}l.isMDXComponent=!0}}]);